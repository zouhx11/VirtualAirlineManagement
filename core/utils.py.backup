# core/utils.py - Fixed version

import json
import sqlite3
import os
import tkinter as tk
from tkinter import ttk
import threading
import time
from functools import wraps

def load_airlines_json():
    """Load airlines from JSON file or database - handles both formats correctly"""
    
    # Try JSON file first
    json_file = 'airline_data.json'
    if os.path.exists(json_file):
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                airlines = json.load(f)
                print(f"âœ… Loaded {len(airlines)} airlines from {json_file}")
                return airlines
        except (json.JSONDecodeError, UnicodeDecodeError) as e:
            print(f"âŒ Error loading {json_file}: {e}")
        except Exception as e:
            print(f"âŒ Unexpected error loading {json_file}: {e}")
    
    # Try SQLite database
    db_file = 'airline_data.db'
    if os.path.exists(db_file):
        try:
            conn = sqlite3.connect(db_file)
            cursor = conn.cursor()
            
            # Check if airlines table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='airlines'")
            if cursor.fetchone():
                cursor.execute("SELECT id, name, icao, iata, country, hub FROM airlines")
                rows = cursor.fetchall()
                conn.close()
                
                airlines = []
                for row in rows:
                    airlines.append({
                        'id': row[0],
                        'name': row[1],
                        'icao': row[2] or '',
                        'iata': row[3] or '',
                        'country': row[4] or 'Unknown',
                        'hub': row[5] or 'KJFK'
                    })
                
                print(f"âœ… Loaded {len(airlines)} airlines from {db_file}")
                return airlines
            else:
                print(f"âŒ No 'airlines' table found in {db_file}")
                conn.close()
                
        except sqlite3.Error as e:
            print(f"âŒ SQLite error loading {db_file}: {e}")
        except Exception as e:
            print(f"âŒ Unexpected error loading {db_file}: {e}")
    
    # If both files fail, check for alternative file names
    alternative_files = ['airlines.json', 'data/airline_data.json', 'data/airlines.json']
    for alt_file in alternative_files:
        if os.path.exists(alt_file):
            try:
                with open(alt_file, 'r', encoding='utf-8') as f:
                    airlines = json.load(f)
                    print(f"âœ… Loaded {len(airlines)} airlines from {alt_file}")
                    return airlines
            except Exception as e:
                print(f"âŒ Error loading {alt_file}: {e}")
                continue
    
    # Return default airlines if no data source found
    print("âš ï¸ No airline data found in any format, creating default airlines")
    
    default_airlines = [
        {
            "id": 1,
            "name": "SkyLine Airways",
            "icao": "SKY",
            "iata": "SL",
            "country": "United States",
            "hub": "KJFK"
        },
        {
            "id": 2,
            "name": "Pacific Airlines", 
            "icao": "PAC",
            "iata": "PA",
            "country": "United States",
            "hub": "KLAX"
        },
        {
            "id": 3,
            "name": "Atlantic Express",
            "icao": "ATL", 
            "iata": "AE",
            "country": "United States",
            "hub": "KATL"
        },
        {
            "id": 4,
            "name": "Continental Airways",
            "icao": "CON",
            "iata": "CO", 
            "country": "United States",
            "hub": "KORD"
        },
        {
            "id": 5,
            "name": "Your Custom Airline",
            "icao": "YCA",
            "iata": "YC",
            "country": "United States", 
            "hub": "KJFK"
        }
    ]
    
    # Save default airlines to JSON for future use
    try:
        with open('airline_data.json', 'w', encoding='utf-8') as f:
            json.dump(default_airlines, f, indent=2, ensure_ascii=False)
        print("âœ… Created airline_data.json with default airlines")
    except Exception as e:
        print(f"âš ï¸ Could not save default airlines: {e}")
    
    return default_airlines

def create_button(parent, text, style, command, icon=None):
    """Create a button with optional icon"""
    try:
        if icon and icon is not None:
            btn = ttk.Button(parent, text=text, bootstyle=style, command=command, image=icon, compound='top')
        else:
            btn = ttk.Button(parent, text=text, bootstyle=style, command=command)
        return btn
    except Exception as e:
        print(f"âš ï¸ Error creating button '{text}': {e}")
        # Fallback button without icon
        return ttk.Button(parent, text=text, bootstyle=style, command=command)

def debounce(wait_time):
    """Decorator to debounce function calls"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            def call_func():
                try:
                    func(*args, **kwargs)
                except Exception as e:
                    print(f"âš ï¸ Debounced function error: {e}")
            
            # Cancel previous call if exists
            if hasattr(wrapper, '_timer'):
                wrapper._timer.cancel()
            
            # Schedule new call
            wrapper._timer = threading.Timer(wait_time / 1000.0, call_func)
            wrapper._timer.start()
        
        return wrapper
    return decorator

def safe_file_operation(operation, filename, *args, **kwargs):
    """Safely perform file operations with error handling"""
    try:
        return operation(filename, *args, **kwargs)
    except FileNotFoundError:
        print(f"âŒ File not found: {filename}")
        return None
    except PermissionError:
        print(f"âŒ Permission denied: {filename}")
        return None
    except Exception as e:
        print(f"âŒ Error with file {filename}: {e}")
        return None

def check_file_encoding(filename):
    """Check and fix file encoding issues"""
    if not os.path.exists(filename):
        return False
    
    try:
        # Try to read with UTF-8
        with open(filename, 'r', encoding='utf-8') as f:
            f.read()
        return True
    except UnicodeDecodeError:
        print(f"âš ï¸ Encoding issue with {filename}")
        try:
            # Try with different encodings
            for encoding in ['latin-1', 'cp1252', 'iso-8859-1']:
                with open(filename, 'r', encoding=encoding) as f:
                    content = f.read()
                # Rewrite with UTF-8
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"âœ… Fixed encoding for {filename}")
                return True
        except Exception as e:
            print(f"âŒ Could not fix encoding for {filename}: {e}")
    except Exception as e:
        print(f"âŒ Error checking {filename}: {e}")
    
    return False

# Debug utilities
def debug_file_contents(filename, max_lines=10):
    """Debug function to safely check file contents"""
    if not os.path.exists(filename):
        print(f"âŒ Debug: File {filename} does not exist")
        return
    
    try:
        print(f"ðŸ” Debug: Checking {filename}")
        print(f"   File size: {os.path.getsize(filename)} bytes")
        
        # Check if it's a binary file (SQLite)
        with open(filename, 'rb') as f:
            first_bytes = f.read(16)
            if first_bytes.startswith(b'SQLite format 3'):
                print(f"   Type: SQLite database")
                return
        
        # Try to read as text
        with open(filename, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            print(f"   Type: Text file ({len(lines)} lines)")
            for i, line in enumerate(lines[:max_lines]):
                print(f"   Line {i+1}: {line.strip()[:100]}...")
                
    except Exception as e:
        print(f"   Error reading: {e}")

# Additional utility functions that may be needed by other modules
def convert_to_int(value, default=0):
    """Convert a value to integer with a default fallback"""
    if value is None:
        return default
    
    try:
        # Handle string representations
        if isinstance(value, str):
            # Remove any whitespace
            value = value.strip()
            # Handle empty strings
            if not value:
                return default
            # Try to convert
            return int(float(value))  # float first to handle "123.0" strings
        
        # Handle numeric types
        if isinstance(value, (int, float)):
            return int(value)
        
        # Fallback for other types
        return int(value)
        
    except (ValueError, TypeError, OverflowError):
        print(f"âš ï¸ Could not convert '{value}' to int, using default {default}")
        return default

def convert_to_float(value, default=0.0):
    """Convert a value to float with a default fallback"""
    if value is None:
        return default
    
    try:
        # Handle string representations
        if isinstance(value, str):
            value = value.strip()
            if not value:
                return default
            return float(value)
        
        # Handle numeric types
        if isinstance(value, (int, float)):
            return float(value)
        
        # Fallback for other types
        return float(value)
        
    except (ValueError, TypeError, OverflowError):
        print(f"âš ï¸ Could not convert '{value}' to float, using default {default}")
        return default

def safe_get_config_value(config, section, key, default=None, value_type=str):
    """Safely get a configuration value with type conversion"""
    try:
        if not config.has_section(section):
            return default
        
        if not config.has_option(section, key):
            return default
        
        value = config.get(section, key)
        
        if value_type == int:
            return convert_to_int(value, default)
        elif value_type == float:
            return convert_to_float(value, default)
        elif value_type == bool:
            return config.getboolean(section, key, fallback=default)
        else:
            return value
            
    except Exception as e:
        print(f"âš ï¸ Error getting config value [{section}][{key}]: {e}")
        return default

def validate_airport_code(code):
    """Validate airport code format (ICAO or IATA)"""
    if not code or not isinstance(code, str):
        return False
    
    code = code.strip().upper()
    
    # ICAO codes are 4 characters, IATA codes are 3
    if len(code) == 4:
        return code.isalpha()  # ICAO: 4 letters
    elif len(code) == 3:
        return code.isalpha()  # IATA: 3 letters
    
    return False

def format_currency(amount, currency_symbol="$"):
    """Format a number as currency"""
    try:
        if amount is None:
            return f"{currency_symbol}0.00"
        
        amount = float(amount)
        
        if abs(amount) >= 1_000_000:
            return f"{currency_symbol}{amount/1_000_000:.1f}M"
        elif abs(amount) >= 1_000:
            return f"{currency_symbol}{amount/1_000:.1f}k"
        else:
            return f"{currency_symbol}{amount:.2f}"
            
    except (ValueError, TypeError):
        return f"{currency_symbol}0.00"

def format_distance(distance_nm):
    """Format distance in nautical miles"""
    try:
        distance = float(distance_nm)
        return f"{distance:,.0f} nm"
    except (ValueError, TypeError):
        return "0 nm"

def format_time_duration(hours):
    """Format time duration in hours to hours:minutes"""
    try:
        total_hours = float(hours)
        hours_part = int(total_hours)
        minutes_part = int((total_hours - hours_part) * 60)
        return f"{hours_part:02d}:{minutes_part:02d}"
    except (ValueError, TypeError):
        return "00:00"

# Backward compatibility aliases
def convert_to_integer(value, default=0):
    """Alias for convert_to_int for backward compatibility"""
    return convert_to_int(value, default)

if __name__ == "__main__":
    # Test the functions
    print("ðŸ§ª Testing airline data loading...")
    airlines = load_airlines_json()
    print(f"Result: {len(airlines)} airlines loaded")
    
    # Test utility functions
    print("\nðŸ§ª Testing utility functions...")
    print(f"convert_to_int('123'): {convert_to_int('123')}")
    print(f"convert_to_int('abc', 42): {convert_to_int('abc', 42)}")
    print(f"format_currency(1250000): {format_currency(1250000)}")
    print(f"validate_airport_code('KJFK'): {validate_airport_code('KJFK')}")
    
    # Debug existing files
    for filename in ['airline_data.json', 'airline_data.db']:
        if os.path.exists(filename):
            debug_file_contents(filename)